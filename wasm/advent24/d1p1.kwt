(module
    (!comment Each page has 65_536 bytes)
    (!comment Let's say the first 1k are for ROM)
    (!boilerplate)
    (data (i32.const 0) "../../advent_of_code_2024/cache/input_1.txt")
    (!comment TODO: allow proper wasm comments)
    (!comment TODO: download the file at comptime)
    (func $main (export "main")
        (local $fileSize i32) (!comment Includes final \x00)

        (local $rawNumbers_ptr i32)
        (local $rawNumbers_len i32)

        (call $logI32 (i32.const 123))
        (!comment memory at $fileSize + (998, 999) is (\n, \x00))
        (!comment memory at $fileSize + 1000 is the next free spot)
        (local.set $fileSize (call $loadFile (i32.const 0) (i32.const 1000)))

        (call $logI32 (call $i32FromString (i32.const 1000) (i32.const 1005)))

        (!local.set ($rawNumbers_ptr $rawNumbers_len) 
            (call $parseFileIntoMemory (i32.const 1000) (i32.add (local.get $fileSize) (i32.const 1000))))

        (call $logI32 (local.get $rawNumbers_ptr))
        (call $logI32 (local.get $rawNumbers_len))
    )

    (func $parseFileIntoMemory (!params $fileStart i32 $memoryStart i32) (result i32 i32)
        (i32.const 1)
        (i32.const 2)
        (!comment TODO))

    (func $i32FromString (!params $start i32 $end i32) (result i32)
        (local $result i32)
        (local.set $result (i32.const 0))

        (block $done
            (loop $continue
                (br_if $done (i32.eq (local.get $start) (local.get $end)))
                (!comment local.set $result (i32.add (i32.const 1) (local.get $result)))
                (local.set $result (i32.mul (i32.const 10) (local.get $result)))
                (local.set $result (i32.add (i32.sub (i32.load8_u (local.get $start)) (!ascii-i32 0)) (local.get $result)))
                (local.set $start (i32.add (i32.const 1) (local.get $start)))
                (br $continue)
            )
        )
        
        (return (local.get $result))
    )
)